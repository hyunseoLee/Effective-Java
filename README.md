# Effective-Java 
이펙티브 자바 책 한권 끝내기 📚

 <img width="159" alt="스크린샷 2022-05-02 오후 6 36 36" src="https://user-images.githubusercontent.com/33533199/166214602-e95279b5-f239-4af3-8b53-20503c0cfa93.png">


<!-- TOC -->
# [목차](#목차)

### 📌 [2장. 객체 생성과 파괴](#2장-객체-생성과-파괴)
  - [아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라](#아이템1-생성자-대신-정적-팩터리-메서드를-고려하라) 
  - [아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라](#아이템2-생성자에-매개변수가-많다면-빌더를-고려하라)
  - 아이템 3. PRIVATE 생성자나 열거 타입으로 싱글턴임을 보증하라 
  - 아이템 4. 인스턴스화를 막으려거든 PRIVATE 생성자를 사용하라 
  - 아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라 
  - 아이템 6. 불필요한 객체 생성을 피하라 
  - 아이템 7. 다 쓴 객체 참조를 해제하라 
  - 아이템 8. FINALIZER와 CLEANER 사용을 피하라 
  - 아이템 9. TRY-FINALLY보다는 TRY-WITH-RESOURCES를 사용하라 

### 📌 3장. 모든 객체의 공통 메서드  
  - 아이템 10. EQUALS는 일반 규약을 지켜 재정의하라 
  - 아이템 11. EQUALS를 재정의하려거든 HASHCODE도 재정의하라 
  - 아이템 12. TOSTRING을 항상 재정의하라 
  - 아이템 13. CLONE 재정의는 주의해서 진행하라 
  - 아이템 14. COMPARABLE을 구현할지 고려하라 


### 📌 5장. 제네릭 
  - 아이템 26. 로 타입은 사용하지 말라 
  - 아이템 27. 비검사 경고를 제거하라 
  - 아이템 28. 배열보다는 리스트를 사용하라 
  - 아이템 29. 이왕이면 제네릭 타입으로 만들라 
  - 아이템 30. 이왕이면 제네릭 메서드로 만들라 
  - 아이템 31. 한정적 와일드카드를 사용해 API 유연성을 높이라 
  - 아이템 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라 
  - 아이템 33. 타입 안전 이종 컨테이너를 고려하라 

### 📌 6장. 열거 타입과 애너테이션 
  - 아이템 34. INT 상수 대신 열거 타입을 사용하라 
  - 아이템 35. ORDINAL 메서드 대신 인스턴스 필드를 사용하라 
  - 아이템 36. 비트 필드 대신 ENUMSET을 사용하라 
  - 아이템 37. ORDINAL 인덱싱 대신 ENUMMAP을 사용하라 
  - 아이템 38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라 
  - 아이템 39. 명명 패턴보다 애너테이션을 사용하라 
  - 아이템 40. @OVERRIDE 애너테이션을 일관되게 사용하라 
  - 아이템 41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라 

### 📌 7장. 람다와 스트림 
  - 아이템 42. 익명 클래스보다는 람다를 사용하라 
  - 아이템 43. 람다보다는 메서드 참조를 사용하라 
  - 아이템 44. 표준 함수형 인터페이스를 사용하라 
  - 아이템 45. 스트림은 주의해서 사용하라 
  - 아이템 46. 스트림에서는 부작용 없는 함수를 사용하라 
  - 아이템 47. 반환 타입으로는 스트림보다 컬렉션이 낫다 
  - 아이템 48. 스트림 병렬화는 주의해서 적용하라 
  
 <!-- /TOC -->
-----------------------------------------------------------------
  
  ## 2장. 객체 생성과 파괴
  ### 아이템1. 생성자 대신 정적 팩터리 메서드를 고려하라. 
  * 클래스는 클라이언트에 public 생성자 대신 (혹은 생성자와 함께) 정적 팩터리 메서드를 제공할 수 있다. 
  * 정적 팩터리 메서드 (static factory method) :  클래스의 인스턴스를 반환하는 단순한 정적 메서드 (리턴값이 그 클래스의 인스턴스값인 메서드) 
```java
// 정적 팩터리 메서드의 예시: 기본타입인 boolean 값을 받아 Boolean 객체 참조로 변환해준다 
public static Boolean valueOf(boolean b) {
  return b ? Boolean.TRUE : Boolean.FALSE; 
}
```

**팩터리 메서드가 생성자보다 좋은 점 (= 장점)**
1. 이름을 가질 수 있다.
  - 생성자에 넘기는 매개변수와 생성자 자체만으로는 반환될 객체의 특성을 제대로 설명하지 못한다. ex) BigInteger(int, int, Random) 
  - 정적 팩터리는 이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있다.  ex) BigInteger.probablePrime 
  - 한 클래스에 시그니처가 같은 생성자가 여러 개 필요할 것 같으면, 생성자를 정적 메서드로 바꾸고 각각의 차이를 잘 드러내는 이름을 지어주자. 
2. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.
  - 불변 클래스(아이템 17)는 인스턴스를 미리 만들어 놓거나 새로 샏성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있다. 
  - 반복되는 요청에 같은 객체를 반환하는 정적 팩터리방식의 클래스를 인스턴스 통제 클래스라 한다. 인스턴스를 통제하면 클래스를 싱글턴으로 만들 수도 있고, 인스턴스화 불가(아이템 4)로 만들수 있다. 또한 불변 값 클래스(아이템 17)에서 동치인 인스턴스가 단 하나뿐임을 보장할 수 있다. 
3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다. 
 - 반환할 객체의 클래스를 자유롭게 선택할 수 있게 하는 '엄청난 유연성'
 - API를 만들때, 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지할 수 있다. 이는 인터페이스를 정적 팩터리 메서드의 반환타입으로 사용하는 인터페이스 기반 프레임워크(아이템 20)을 만드는 핵심 기술. 
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다. 
- 반환 타입의 하위타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다.
- ex.EnumSet 클래스(아이템 36) 
5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다. (?) 

**단점**
1. 상속을 하려면 public 이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다. 

> 정리 

    정적 팩토리 메서드와 public생성자는 각자의 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋다. 
    그렇다고 하더라도 정적 팩터리를 사용하는게 유리한 경우가 더 많으므로 무작정 public 생성자를 제공하던 습관이 있다면 고치자. 
    
---------------------------------------------------------------------------------------
  ### 아이템2. 생성자에 매개변수가 많다면 빌더를 고려하라

