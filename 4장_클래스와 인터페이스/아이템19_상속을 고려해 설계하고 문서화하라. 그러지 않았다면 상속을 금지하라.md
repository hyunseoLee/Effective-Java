## 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.

#### 상속을 고려한 설계화 문서화란?  
1. 메서드를 재정의하면 어떤 일이 일어나는지 정확히 정리하여 문서로 남겨야 한다.
- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.
  - '재정의 가능'이란 public과 protected 메서드 중 final이 아닌 모든 메서드 
- API 문서의 메서드 설며 끝에 종종  **"Implementation Requirements"** 로 시작하는 절이, 그 메서드의 내부 동작 방식을 설명하는 곳이다.
  - 이 절은 메서드 주석에 @implSpec 태그를 붙여주면 자바독 도구가 생성해준다. @implSpec 는 자바8에 처음 도입되어 자바9부터 본격적으로 사용되기 시작했다. 이 태그를 활성화하려면 명령줄 매개변수로 -tag "implSpec: a:Implementation Requirements:"를 지정해주면된다. 

2. 클래스의 내부 동작 과정 중간에 끼어드 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다. 
- 어떤 메서드를 protected로 노출해야될지 결정할 명확한 정답은 없지만, protected메서드의 수는 가능한 한 적어야 한다. 

#### 상속용 클래스 고려할점
- 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.
- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다. 

- '상위클래스 생성자 실행 > 하위클래스 재정의 메서드 호출 > 하위클래스 생성자 호출' 되므로, 재정의한 메서드가 하위클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작하지 않을 것이다. 
- 아래 예시. 상위클래스 생성자에서 하위클래스 재정의메서드를 호출하고 있다. 
- 상위클래스의 생성자느 하위클래스의 생성자가 인스턴스 필드를 초기화하기도 전에 overrideMe를 호출하고 있다. 

```java
public class Super{
//잘못된 예. 생성자가 재정의 가능 메서드를 호출한다. 
  public Super(){
    overrideMe();
 }
 public void overrideMe(){ ... } 
}
```

```java
public final class Sub extends Super{
  //초기화되 않은 final 필드. 생성자에서 초기화한다.
  private final Instant instant;
  Sub(){ instant= Instant.now(); } 
 
 @Override // 재정의가느 메서드. 상위클래스으 생성자가 호출한다. 
 public void overrideMe(){ 
  System.out.println(instant);
 } 
}
```

- 클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스에 안기는 제약도 상당하다.

#### 상속용으로 설계하지 않은 클래스는 상속을 금지하자.
1. 클래스를 final로 선언하는 방법 
2. 모든 생성자를 private 이나 package-private(=default)로 선언하고 public 정적 팩터리를 만들어주는 방법 

>정리

 상속용 클래스를 설계하기란 결코 만만치 않다. 클래스 내부에서 스스로를 어떻게 사용하는지(자기사용 패턴) 모두 문서로 남겨야 하며, 일단 문서화한 것으 그 클래스가 쓰이느 한 반드시 지켜야 한다.
 그러지 않으면 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 만들 수 있다. 다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있다. 그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 나을 것이다. 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들며 된다. 

